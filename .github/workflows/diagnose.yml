name: Server Diagnostics

on:
  workflow_dispatch:
    inputs:
      auto_fix:
        description: 'Attempt automatic fixes for detected issues'
        type: boolean
        default: false
      target_service:
        description: 'Service to diagnose'
        type: choice
        default: 'all'
        options:
          - all
          - linktree_app
          - immocalc
          - rigpilot
          - cosmic-survivor
          - minecraft-web
      discovery_mode:
        description: 'Discovery mode'
        type: choice
        default: 'quick'
        options:
          - quick
          - full
          - paranoid
      auto_learn:
        description: 'Auto-add discovered healthy services to config'
        type: boolean
        default: false
      notify_unknown:
        description: 'Create GitHub issue when unknown services are found'
        type: boolean
        default: false

jobs:
  diagnose:
    name: Run Diagnostics
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Read known services config
        id: config
        run: |
          if [[ -f ".github/config/known-services.json" ]]; then
            echo "config_exists=true" >> $GITHUB_OUTPUT
            # Extract service names as comma-separated list
            SERVICES=$(jq -r '.services | keys | join(",")' .github/config/known-services.json)
            echo "services=$SERVICES" >> $GITHUB_OUTPUT
            # Pass the entire config as base64 to avoid shell escaping issues
            CONFIG_B64=$(base64 -w 0 < .github/config/known-services.json)
            echo "config_b64=$CONFIG_B64" >> $GITHUB_OUTPUT
          else
            echo "config_exists=false" >> $GITHUB_OUTPUT
            echo "services=" >> $GITHUB_OUTPUT
            echo "config_b64=" >> $GITHUB_OUTPUT
          fi

      - name: Run Diagnostics
        id: diagnostics
        uses: appleboy/ssh-action@v1.0.3
        env:
          AUTO_FIX: ${{ inputs.auto_fix }}
          TARGET_SERVICE: ${{ inputs.target_service }}
          DISCOVERY_MODE: ${{ inputs.discovery_mode }}
          AUTO_LEARN: ${{ inputs.auto_learn }}
          CONFIG_B64: ${{ steps.config.outputs.config_b64 }}
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: AUTO_FIX,TARGET_SERVICE,DISCOVERY_MODE,AUTO_LEARN,CONFIG_B64
          command_timeout: 15m
          script: |
            set -uo pipefail
            
            # ==========================================
            # Configuration
            # ==========================================
            
            # Decode config from base64
            if [[ -n "${CONFIG_B64:-}" ]]; then
              KNOWN_SERVICES_JSON=$(echo "$CONFIG_B64" | base64 -d)
            else
              KNOWN_SERVICES_JSON='{}'
            fi
            
            # Service configuration: container_name -> internal_port,domain,deploy_dir
            # Built dynamically from JSON config
            declare -A SERVICE_CONFIG
            
            # Parse services from JSON config
            if command -v jq &> /dev/null && [[ -n "${KNOWN_SERVICES_JSON:-}" ]]; then
              while IFS='|' read -r name port domain deploy_dir; do
                if [[ -n "$name" ]]; then
                  SERVICE_CONFIG["$name"]="${port},${domain},${deploy_dir}"
                fi
              done < <(echo "$KNOWN_SERVICES_JSON" | jq -r '.services | to_entries[] | "\(.key)|\(.value.port)|\(.value.domain)|\(.value.deploy_dir)"' 2>/dev/null || true)
            fi
            
            # Fallback to hardcoded config if parsing failed
            if [[ ${#SERVICE_CONFIG[@]} -eq 0 ]]; then
              SERVICE_CONFIG["linktree_app"]="8000,festas-builds.com,/home/deploy/link-in-bio"
              SERVICE_CONFIG["immocalc"]="3000,immocalc.festas-builds.com,/home/deploy/immocalc"
              SERVICE_CONFIG["rigpilot"]="3000,rigpilot.festas-builds.com,/home/deploy/rigpilot"
              SERVICE_CONFIG["cosmic-survivor"]="80,cs.festas-builds.com,/home/deploy/cosmic-survivor"
              SERVICE_CONFIG["minecraft-web"]="80,mc.festas-builds.com,/home/deploy/minecraft-server"
            fi
            
            # Required domains from JSON config or fallback
            REQUIRED_DOMAINS=()
            if command -v jq &> /dev/null && [[ -n "${KNOWN_SERVICES_JSON:-}" ]]; then
              while IFS= read -r domain; do
                if [[ -n "$domain" ]]; then
                  REQUIRED_DOMAINS+=("$domain")
                fi
              done < <(echo "$KNOWN_SERVICES_JSON" | jq -r '.required_domains[]' 2>/dev/null || true)
            fi
            
            # Fallback to hardcoded domains if parsing failed
            if [[ ${#REQUIRED_DOMAINS[@]} -eq 0 ]]; then
              REQUIRED_DOMAINS=(
                "festas-builds.com"
                "admin.festas-builds.com"
                "rigpilot.festas-builds.com"
                "immocalc.festas-builds.com"
                "mc.festas-builds.com"
                "cs.festas-builds.com"
              )
            fi
            
            # Track issues and warnings
            ISSUES=()
            WARNINGS=()
            
            add_issue() {
              ISSUES+=("$1")
            }
            
            add_warning() {
              WARNINGS+=("$1")
            }
            
            # Get service config values
            get_port() {
              echo "${SERVICE_CONFIG[$1]}" | cut -d',' -f1
            }
            
            get_domain() {
              echo "${SERVICE_CONFIG[$1]}" | cut -d',' -f2
            }
            
            get_deploy_dir() {
              echo "${SERVICE_CONFIG[$1]}" | cut -d',' -f3
            }
            
            # Check if docker compose file exists in a directory
            has_compose_file() {
              local dir="$1"
              [[ -d "$dir" ]] && [[ -f "${dir}/docker-compose.yml" || -f "${dir}/docker-compose.yaml" || -f "${dir}/compose.yml" || -f "${dir}/compose.yaml" ]]
            }
            
            # Check if Caddy container is running
            is_caddy_running() {
              docker ps --format '{{.Names}}' | grep -q '^caddy_server$'
            }
            
            # Filter services based on target
            get_target_services() {
              if [[ "${TARGET_SERVICE}" == "all" ]]; then
                echo "${!SERVICE_CONFIG[@]}"
              else
                echo "${TARGET_SERVICE}"
              fi
            }
            
            # ==========================================
            # Discovery Arrays
            # ==========================================
            declare -A DISCOVERED_CONTAINERS
            declare -a UNKNOWN_CONTAINERS
            declare -a MISSING_SERVICES
            declare -a ANOMALIES
            declare -a HEALTHY_UNKNOWN
            
            # JSON output for artifacts
            DISCOVERY_JSON='{}'
            
            echo "=========================================="
            echo "üîç Server Diagnostics Report"
            echo "=========================================="
            echo "Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            echo "Target: ${TARGET_SERVICE}"
            echo "Auto-fix: ${AUTO_FIX}"
            echo "Discovery Mode: ${DISCOVERY_MODE:-quick}"
            echo "Auto-learn: ${AUTO_LEARN:-false}"
            echo ""
            
            # ==========================================
            # Auto-Discovery Phase
            # ==========================================
            
            echo "=========================================="
            echo "üîé AUTO-DISCOVERY PHASE"
            echo "=========================================="
            echo ""
            
            # Container Discovery
            echo "--- Container Discovery ---"
            echo ""
            
            # Get all containers (running and stopped)
            ALL_CONTAINERS=$(docker ps -a --format '{{.Names}}|{{.Status}}|{{.Ports}}|{{.Image}}|{{.CreatedAt}}' 2>/dev/null || echo "")
            RUNNING_CONTAINERS=$(docker ps --format '{{.Names}}' 2>/dev/null || echo "")
            
            echo "All containers found:"
            echo "$ALL_CONTAINERS" | while IFS='|' read -r name status ports image created; do
              if [[ -n "$name" ]]; then
                echo "  - $name (${status%% *})"
              fi
            done
            echo ""
            
            # Classify containers
            echo "Container Classification:"
            while IFS='|' read -r name status ports image created; do
              if [[ -z "$name" ]]; then continue; fi
              
              if [[ -v "SERVICE_CONFIG[$name]" ]]; then
                if echo "$RUNNING_CONTAINERS" | grep -qw "$name"; then
                  echo "  ‚úÖ KNOWN: $name (running)"
                  DISCOVERED_CONTAINERS["$name"]="known|running|$ports|$image"
                else
                  echo "  ‚ö†Ô∏è  MISSING: $name (not running, status: ${status%% *})"
                  MISSING_SERVICES+=("$name")
                  DISCOVERED_CONTAINERS["$name"]="missing|${status%% *}|$ports|$image"
                fi
              else
                # Skip caddy_server as it's infrastructure
                if [[ "$name" == "caddy_server" ]]; then
                  echo "  ‚ÑπÔ∏è  INFRASTRUCTURE: $name"
                  continue
                fi
                echo "  ‚ùì UNKNOWN: $name (image: $image)"
                UNKNOWN_CONTAINERS+=("$name|$status|$ports|$image|$created")
                DISCOVERED_CONTAINERS["$name"]="unknown|${status%% *}|$ports|$image"
              fi
            done <<< "$ALL_CONTAINERS"
            echo ""
            
            # Check for missing known services (not even stopped containers exist)
            for service in "${!SERVICE_CONFIG[@]}"; do
              if ! echo "$ALL_CONTAINERS" | grep -q "^$service|"; then
                echo "  ‚ùå MISSING (no container): $service"
                MISSING_SERVICES+=("$service")
              fi
            done
            echo ""
            
            # Network Discovery (full and paranoid modes)
            if [[ "${DISCOVERY_MODE:-quick}" != "quick" ]]; then
              echo "--- Network Discovery ---"
              echo ""
              
              echo "All Docker networks:"
              docker network ls --format '{{.Name}}\t{{.Driver}}' 2>/dev/null || echo "Failed to list networks"
              echo ""
              
              # Check network connectivity for each container
              echo "Network connections:"
              for network in $(docker network ls --format '{{.Name}}' 2>/dev/null); do
                if [[ "$network" == "bridge" || "$network" == "host" || "$network" == "none" ]]; then
                  continue
                fi
                CONNECTED=$(docker network inspect "$network" --format '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null || echo "")
                if [[ -n "$CONNECTED" ]]; then
                  echo "  $network: $CONNECTED"
                fi
              done
              echo ""
              
              # Find containers not on caddy-network
              CADDY_NETWORK_CONTAINERS=$(docker network inspect caddy-network --format '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null || echo "")
              echo "Containers NOT on caddy-network:"
              for name in $(docker ps --format '{{.Names}}' 2>/dev/null); do
                if [[ "$name" == "caddy_server" ]]; then continue; fi
                if ! echo "$CADDY_NETWORK_CONTAINERS" | grep -qw "$name"; then
                  echo "  ‚ö†Ô∏è  $name"
                  ANOMALIES+=("$name is not on caddy-network")
                fi
              done
              echo ""
            fi
            
            # Port Discovery (full and paranoid modes)
            if [[ "${DISCOVERY_MODE:-quick}" != "quick" ]]; then
              echo "--- Port Discovery ---"
              echo ""
              
              echo "All listening ports on host:"
              ss -tlnp 2>/dev/null | head -30 || netstat -tlnp 2>/dev/null | head -30 || echo "Could not list ports"
              echo ""
              
              # Docker port mappings
              echo "Docker port mappings:"
              docker ps --format '{{.Names}}\t{{.Ports}}' 2>/dev/null | grep -v "^$" || echo "  (none)"
              echo ""
            fi
            
            # Deploy Directory Scan (full and paranoid modes)
            if [[ "${DISCOVERY_MODE:-quick}" != "quick" ]]; then
              echo "--- Deploy Directory Scan ---"
              echo ""
              
              echo "Scanning /home/deploy for docker-compose projects..."
              DEPLOY_DIRS_FOUND=()
              for dir in /home/deploy/*/; do
                if [[ -d "$dir" ]]; then
                  DIR_NAME=$(basename "$dir")
                  if [[ -f "${dir}docker-compose.yml" || -f "${dir}docker-compose.yaml" || -f "${dir}compose.yml" || -f "${dir}compose.yaml" ]]; then
                    DEPLOY_DIRS_FOUND+=("$dir")
                    # Check if there's a running container for this directory
                    HAS_RUNNING=false
                    for service in "${!SERVICE_CONFIG[@]}"; do
                      SVC_DIR=$(get_deploy_dir "$service")
                      if [[ "${SVC_DIR%/}" == "${dir%/}" ]]; then
                        if echo "$RUNNING_CONTAINERS" | grep -qw "$service"; then
                          HAS_RUNNING=true
                          break
                        fi
                      fi
                    done
                    if [[ "$HAS_RUNNING" == "true" ]]; then
                      echo "  ‚úÖ $dir (has running container)"
                    else
                      echo "  ‚ö†Ô∏è  $dir (NO running container)"
                      ANOMALIES+=("Deploy dir $dir has no running container")
                    fi
                  else
                    echo "  ‚ÑπÔ∏è  $dir (no compose file)"
                  fi
                fi
              done
              echo ""
            fi
            
            # Caddy Routes Discovery (full and paranoid modes)
            if [[ "${DISCOVERY_MODE:-quick}" != "quick" ]] && is_caddy_running; then
              echo "--- Caddy Routes Discovery ---"
              echo ""
              
              echo "Configured domains in Caddyfile:"
              ACTIVE_CADDYFILE_DISCOVERY=$(docker exec caddy_server cat /etc/caddy/Caddyfile 2>&1 || echo "Failed to read Caddyfile")
              echo "$ACTIVE_CADDYFILE_DISCOVERY" | grep -E '^[a-zA-Z0-9].*\{' | sed 's/{.*//' | while read -r domain; do
                echo "  - $domain"
              done
              echo ""
              
              echo "Reverse proxy backends:"
              echo "$ACTIVE_CADDYFILE_DISCOVERY" | grep -E 'reverse_proxy' | while read -r line; do
                echo "  $line"
              done
              echo ""
            fi
            
            # Process Scan (paranoid mode only)
            if [[ "${DISCOVERY_MODE:-quick}" == "paranoid" ]]; then
              echo "--- Process Scan (Paranoid Mode) ---"
              echo ""
              
              echo "Top processes by memory:"
              ps aux --sort=-%mem | head -15 || echo "Could not list processes"
              echo ""
              
              echo "Processes listening on common web ports (80, 443, 8000, 3000):"
              ss -tlnp 2>/dev/null | grep -E ':80|:443|:8000|:3000' || echo "  (none found)"
              echo ""
            fi
            
            # Discovery Summary
            echo "=========================================="
            echo "üìä Discovery Summary"
            echo "=========================================="
            echo ""
            echo "Known services: ${#SERVICE_CONFIG[@]}"
            echo "Unknown containers: ${#UNKNOWN_CONTAINERS[@]}"
            echo "Missing services: ${#MISSING_SERVICES[@]}"
            echo "Anomalies: ${#ANOMALIES[@]}"
            echo ""
            
            if [[ ${#UNKNOWN_CONTAINERS[@]} -gt 0 ]]; then
              echo "Unknown containers details:"
              for entry in "${UNKNOWN_CONTAINERS[@]}"; do
                IFS='|' read -r name status ports image created <<< "$entry"
                echo "  - $name"
                echo "    Image: $image"
                echo "    Status: $status"
                echo "    Ports: ${ports:-none}"
                echo ""
                
                # Check if unknown container is healthy (running)
                if [[ "$status" == Up* ]]; then
                  HEALTHY_UNKNOWN+=("$name|$ports|$image")
                fi
              done
            fi
            
            if [[ ${#ANOMALIES[@]} -gt 0 ]]; then
              echo "Anomalies detected:"
              for anomaly in "${ANOMALIES[@]}"; do
                echo "  - $anomaly"
              done
              echo ""
            fi
            
            # Build discovery JSON for output
            DISCOVERY_TIMESTAMP=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
            DISCOVERY_JSON=$(cat <<EOF
            {
              "timestamp": "${DISCOVERY_TIMESTAMP}",
              "discovery_mode": "${DISCOVERY_MODE:-quick}",
              "summary": {
                "known_services": ${#SERVICE_CONFIG[@]},
                "unknown_containers": ${#UNKNOWN_CONTAINERS[@]},
                "missing_services": ${#MISSING_SERVICES[@]},
                "anomalies": ${#ANOMALIES[@]},
                "healthy_unknown": ${#HEALTHY_UNKNOWN[@]}
              },
              "unknown_containers": [
            EOF
            )
            
            # Add unknown containers to JSON
            FIRST=true
            for entry in "${UNKNOWN_CONTAINERS[@]}"; do
              IFS='|' read -r name status ports image created <<< "$entry"
              if [[ "$FIRST" == "true" ]]; then
                FIRST=false
              else
                DISCOVERY_JSON+=","
              fi
              DISCOVERY_JSON+=$(cat <<EOF
            
                {
                  "name": "${name}",
                  "status": "${status}",
                  "ports": "${ports}",
                  "image": "${image}",
                  "created": "${created}"
                }
            EOF
            )
            done
            
            DISCOVERY_JSON+=$(cat <<EOF
            
              ],
              "missing_services": [
            EOF
            )
            
            FIRST=true
            for svc in "${MISSING_SERVICES[@]}"; do
              if [[ "$FIRST" == "true" ]]; then
                FIRST=false
              else
                DISCOVERY_JSON+=","
              fi
              DISCOVERY_JSON+="\"${svc}\""
            done
            
            DISCOVERY_JSON+=$(cat <<EOF
            
              ],
              "anomalies": [
            EOF
            )
            
            FIRST=true
            for anomaly in "${ANOMALIES[@]}"; do
              if [[ "$FIRST" == "true" ]]; then
                FIRST=false
              else
                DISCOVERY_JSON+=","
              fi
              DISCOVERY_JSON+="\"${anomaly}\""
            done
            
            DISCOVERY_JSON+=$(cat <<EOF
            
              ],
              "healthy_unknown": [
            EOF
            )
            
            FIRST=true
            for entry in "${HEALTHY_UNKNOWN[@]}"; do
              IFS='|' read -r name ports image <<< "$entry"
              if [[ "$FIRST" == "true" ]]; then
                FIRST=false
              else
                DISCOVERY_JSON+=","
              fi
              DISCOVERY_JSON+=$(cat <<EOF
            
                {
                  "name": "${name}",
                  "ports": "${ports}",
                  "image": "${image}"
                }
            EOF
            )
            done
            
            DISCOVERY_JSON+=$(cat <<EOF
            
              ]
            }
            EOF
            )
            
            # Output discovery JSON for workflow parsing
            echo ""
            echo "DISCOVERY_JSON_START"
            echo "$DISCOVERY_JSON"
            echo "DISCOVERY_JSON_END"
            echo ""
            
            # ==========================================
            # Step 1: Diagnostic Checks
            # ==========================================
            
            echo "=========================================="
            echo "üìä 1. Container Status Overview"
            echo "=========================================="
            echo ""
            echo "All running containers:"
            docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || {
              add_issue "Docker daemon may not be running"
              echo "‚ùå Failed to list containers"
            }
            echo ""
            
            echo "Caddy container status:"
            if docker ps --format '{{.Names}}' | grep -q '^caddy_server$'; then
              CADDY_STATUS=$(docker inspect --format '{{.State.Status}}' caddy_server 2>/dev/null || echo "unknown")
              echo "‚úÖ caddy_server is running (status: ${CADDY_STATUS})"
            else
              add_issue "Caddy container (caddy_server) is not running"
              echo "‚ùå caddy_server is NOT running"
            fi
            echo ""
            
            echo "=========================================="
            echo "üåê 2. caddy-network Inspection"
            echo "=========================================="
            echo ""
            
            if docker network inspect caddy-network >/dev/null 2>&1; then
              echo "‚úÖ caddy-network exists"
              echo ""
              echo "Connected containers:"
              docker network inspect caddy-network --format '{{range .Containers}}  - {{.Name}}{{println}}{{end}}' 2>/dev/null || echo "  (none)"
              
              CONNECTED_CONTAINERS=$(docker network inspect caddy-network --format '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null || echo "")
              
              for service in $(get_target_services); do
                if echo "$CONNECTED_CONTAINERS" | grep -qw "$service"; then
                  echo "‚úÖ ${service} is connected to caddy-network"
                else
                  if docker ps -a --format '{{.Names}}' | grep -q "^${service}$"; then
                    add_warning "${service} exists but is not connected to caddy-network"
                    echo "‚ö†Ô∏è  ${service} exists but is NOT connected to caddy-network"
                  else
                    add_warning "${service} container does not exist"
                    echo "‚ö†Ô∏è  ${service} container does not exist"
                  fi
                fi
              done
            else
              add_issue "caddy-network does not exist"
              echo "‚ùå caddy-network does NOT exist"
            fi
            echo ""
            
            echo "=========================================="
            echo "üîó 3. Internal Connectivity Tests"
            echo "=========================================="
            echo ""
            echo "Testing if Caddy can reach each service..."
            echo ""
            
            if is_caddy_running; then
              for service in $(get_target_services); do
                port=$(get_port "$service")
                echo "Testing ${service}:${port}..."
                
                # Try wget first (available in Caddy container), then curl as fallback
                if docker exec caddy_server wget -q --spider --timeout=5 "http://${service}:${port}/" 2>/dev/null; then
                  echo "‚úÖ ${service}:${port} is reachable from Caddy"
                elif docker exec caddy_server curl -sf --connect-timeout 5 "http://${service}:${port}/" >/dev/null 2>&1; then
                  echo "‚úÖ ${service}:${port} is reachable from Caddy (via curl)"
                else
                  add_issue "Cannot reach ${service}:${port} from Caddy container"
                  echo "‚ùå ${service}:${port} is NOT reachable from Caddy"
                fi
              done
            else
              add_issue "Caddy container not running - cannot test internal connectivity"
              echo "‚ùå Caddy container is not running - skipping connectivity tests"
            fi
            echo ""
            
            echo "=========================================="
            echo "üìù 4. Caddy Configuration"
            echo "=========================================="
            echo ""
            
            CADDY_CONFIG_PATH=""
            for path in "/srv/link-in-bio/Caddyfile" "/home/deploy/link-in-bio/Caddyfile"; do
              if [[ -f "$path" ]]; then
                CADDY_CONFIG_PATH="$path"
                break
              fi
            done
            
            if [[ -n "$CADDY_CONFIG_PATH" ]]; then
              echo "Caddyfile location: ${CADDY_CONFIG_PATH}"
              echo "---"
              cat "${CADDY_CONFIG_PATH}"
              echo "---"
            else
              add_warning "Caddyfile not found in expected locations"
              echo "‚ö†Ô∏è  Caddyfile not found"
            fi
            echo ""
            
            echo "=========================================="
            echo "üì¶ 4b. Active Caddyfile from Container"
            echo "=========================================="
            echo ""
            
            if is_caddy_running; then
              echo "Reading active Caddyfile from Caddy container..."
              echo "---"
              ACTIVE_CADDYFILE=$(docker exec caddy_server cat /etc/caddy/Caddyfile 2>&1 || echo "Failed to read Caddyfile from container")
              echo "$ACTIVE_CADDYFILE"
              echo "---"
            else
              add_warning "Caddy container not running - cannot read active Caddyfile"
              echo "‚ö†Ô∏è  Cannot read active Caddyfile - Caddy container is not running"
            fi
            echo ""
            
            echo "=========================================="
            echo "üîç 4c. Caddyfile Sync Check"
            echo "=========================================="
            echo ""
            
            CADDYFILE_MISSING_DOMAINS=()
            
            if is_caddy_running; then
              echo "Checking if all required domains are configured in the active Caddyfile..."
              for domain in "${REQUIRED_DOMAINS[@]}"; do
                # Check if the domain is present in the active Caddyfile (flexible pattern to handle spacing)
                if echo "$ACTIVE_CADDYFILE" | grep -qE "(^|[[:space:]])${domain}[[:space:]]*\{"; then
                  echo "‚úÖ ${domain} is configured"
                else
                  add_issue "Caddyfile is missing entry for ${domain} - run deploy workflow to sync"
                  CADDYFILE_MISSING_DOMAINS+=("$domain")
                  echo "‚ùå ${domain} is NOT configured in Caddyfile"
                fi
              done
            else
              echo "‚ö†Ô∏è  Caddy container not running - cannot check domain configuration"
            fi
            echo ""
            
            echo "=========================================="
            echo "‚úîÔ∏è  5. Caddy Config Validation"
            echo "=========================================="
            echo ""
            
            if docker exec caddy_server caddy validate --config /etc/caddy/Caddyfile 2>&1; then
              echo "‚úÖ Caddy configuration is valid"
            else
              add_issue "Caddy configuration validation failed"
              echo "‚ùå Caddy configuration is INVALID"
            fi
            echo ""
            
            echo "=========================================="
            echo "üìã 6. Caddy Logs Analysis"
            echo "=========================================="
            echo ""
            
            echo "Recent Caddy logs (last 50 lines):"
            CADDY_LOGS=$(docker logs caddy_server --tail 50 2>&1 || echo "Failed to retrieve logs")
            echo "$CADDY_LOGS"
            echo ""
            
            # Check for common issues in logs
            echo "Checking for issues in logs..."
            if echo "$CADDY_LOGS" | grep -qi "error"; then
              add_warning "Errors found in Caddy logs"
              echo "‚ö†Ô∏è  Errors detected in Caddy logs"
            else
              echo "‚úÖ No errors found in recent Caddy logs"
            fi
            
            if echo "$CADDY_LOGS" | grep -qi "tls\|certificate\|acme"; then
              if echo "$CADDY_LOGS" | grep -qi "failed\|error\|unable"; then
                add_warning "TLS/certificate issues detected in Caddy logs"
                echo "‚ö†Ô∏è  TLS/certificate issues detected"
              else
                echo "‚úÖ TLS mentions found but no issues detected"
              fi
            fi
            echo ""
            
            echo "=========================================="
            echo "üê≥ 6b. Docker Image Name Validation"
            echo "=========================================="
            echo ""
            
            echo "Checking docker-compose.yml files for image naming issues..."
            DOCKER_COMPOSE_ISSUES=()
            
            for service in $(get_target_services); do
              deploy_dir=$(get_deploy_dir "$service")
              for compose_file in "docker-compose.yml" "docker-compose.yaml" "compose.yml" "compose.yaml"; do
                if [[ -f "${deploy_dir}/${compose_file}" ]]; then
                  echo "Checking ${deploy_dir}/${compose_file}..."
                  
                  # Check for uppercase letters in image names (after the registry/org part)
                  # Extract image names and check for uppercase in the image name portion
                  while IFS= read -r line; do
                    IMAGE_VALUE=$(echo "$line" | sed 's/.*image:[[:space:]]*//' | tr -d '"' | tr -d "'" || true)
                    if [[ -n "$IMAGE_VALUE" ]]; then
                      # Get the image name part (after the last / if present)
                      IMAGE_NAME_PART="${IMAGE_VALUE##*/}"
                      # Check for uppercase in the image name (excluding tags after :)
                      IMAGE_NAME_ONLY="${IMAGE_NAME_PART%%:*}"
                      if echo "$IMAGE_NAME_ONLY" | grep -qE '[A-Z]'; then
                        add_issue "Docker image name contains uppercase in ${deploy_dir}/${compose_file} - fix docker-compose.yml"
                        DOCKER_COMPOSE_ISSUES+=("${deploy_dir}/${compose_file}: Uppercase in image name '${IMAGE_VALUE}'")
                        echo "‚ùå Found uppercase in image name: ${IMAGE_VALUE}"
                      fi
                    fi
                  done < <(grep -E '^\s*image:' "${deploy_dir}/${compose_file}" 2>/dev/null || true)
                  
                  if [[ ${#DOCKER_COMPOSE_ISSUES[@]} -eq 0 ]]; then
                    echo "‚úÖ No uppercase letters in image names"
                  fi
                  
                  break  # Only check first compose file found
                fi
              done
            done
            
            if [[ ${#DOCKER_COMPOSE_ISSUES[@]} -eq 0 ]]; then
              echo "‚úÖ No Docker image naming issues found"
            fi
            echo ""
            
            echo "=========================================="
            echo "üè• 7. Service Health Checks"
            echo "=========================================="
            echo ""
            
            for service in $(get_target_services); do
              echo "Checking ${service}..."
              
              if docker ps -a --format '{{.Names}}' | grep -q "^${service}$"; then
                STATUS=$(docker inspect --format '{{.State.Status}}' "$service" 2>/dev/null || echo "unknown")
                HEALTH=$(docker inspect --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}no healthcheck{{end}}' "$service" 2>/dev/null || echo "unknown")
                
                if [[ "$STATUS" == "running" ]]; then
                  echo "‚úÖ ${service}: running (health: ${HEALTH})"
                  if [[ "$HEALTH" == "unhealthy" ]]; then
                    add_warning "${service} is running but unhealthy"
                  fi
                else
                  add_issue "${service} is not running (status: ${STATUS})"
                  echo "‚ùå ${service}: ${STATUS} (not running)"
                  
                  # When a container fails to start, check for image issues
                  deploy_dir=$(get_deploy_dir "$service")
                  if [[ -f "${deploy_dir}/docker-compose.yml" ]]; then
                    echo "  Checking docker-compose.yml for potential issues..."
                    COMPOSE_IMAGES=$(grep -E '^\s*image:' "${deploy_dir}/docker-compose.yml" 2>/dev/null || true)
                    if [[ -n "$COMPOSE_IMAGES" ]]; then
                      echo "  Images configured:"
                      echo "$COMPOSE_IMAGES" | sed 's/^/    /'
                      if echo "$COMPOSE_IMAGES" | grep -qE '[A-Z]'; then
                        echo "  üí° Suggestion: Docker image name contains uppercase - fix docker-compose.yml"
                      fi
                    fi
                  fi
                fi
              else
                add_warning "${service} container does not exist"
                echo "‚ö†Ô∏è  ${service}: container does not exist"
              fi
            done
            echo ""
            
            echo "=========================================="
            echo "üåç 8. DNS Resolution"
            echo "=========================================="
            echo ""
            
            for service in $(get_target_services); do
              domain=$(get_domain "$service")
              echo "Checking DNS for ${domain}..."
              
              RESOLVED_IP=$(dig +short "$domain" 2>/dev/null | grep -E '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$' | head -1)
              if [[ -n "$RESOLVED_IP" ]]; then
                echo "‚úÖ ${domain} resolves to ${RESOLVED_IP}"
              else
                add_warning "DNS resolution failed for ${domain}"
                echo "‚ö†Ô∏è  ${domain} - DNS resolution failed"
              fi
            done
            echo ""
            
            echo "=========================================="
            echo "üåê 8b. External Connectivity Tests"
            echo "=========================================="
            echo ""
            
            echo "Testing if domains are accessible from the internet (via HTTPS)..."
            EXTERNAL_CONNECTIVITY_ISSUES=()
            
            for service in $(get_target_services); do
              domain=$(get_domain "$service")
              echo "Testing https://${domain}..."
              
              # Test external HTTPS connectivity with timeout
              if curl -sf --connect-timeout 10 "https://${domain}" > /dev/null 2>&1; then
                echo "‚úÖ https://${domain} is accessible from the internet"
              else
                # Try with -k to ignore certificate issues (to distinguish between cert vs connectivity issues)
                if curl -sfk --connect-timeout 10 "https://${domain}" > /dev/null 2>&1; then
                  add_warning "https://${domain} is accessible but has SSL certificate issues"
                  EXTERNAL_CONNECTIVITY_ISSUES+=("${domain}: SSL certificate issue")
                  echo "‚ö†Ô∏è  https://${domain} is accessible but has SSL certificate issues"
                else
                  add_issue "https://${domain} is NOT accessible from the internet"
                  EXTERNAL_CONNECTIVITY_ISSUES+=("${domain}: Not accessible")
                  echo "‚ùå https://${domain} is NOT accessible from the internet"
                fi
              fi
            done
            
            # Also test the admin subdomain explicitly if not already covered
            echo ""
            echo "Testing admin.festas-builds.com..."
            if curl -sf --connect-timeout 10 "https://admin.festas-builds.com" > /dev/null 2>&1; then
              echo "‚úÖ https://admin.festas-builds.com is accessible from the internet"
            else
              if curl -sfk --connect-timeout 10 "https://admin.festas-builds.com" > /dev/null 2>&1; then
                add_warning "https://admin.festas-builds.com is accessible but has SSL certificate issues"
                echo "‚ö†Ô∏è  https://admin.festas-builds.com is accessible but has SSL certificate issues"
              else
                add_issue "https://admin.festas-builds.com is NOT accessible from the internet"
                echo "‚ùå https://admin.festas-builds.com is NOT accessible from the internet"
              fi
            fi
            echo ""
            
            echo "=========================================="
            echo "üîí 9. SSL Certificate Status"
            echo "=========================================="
            echo ""
            
            # Check Caddy's certificate storage
            echo "Caddy certificate storage:"
            if docker exec caddy_server ls -la /data/caddy/certificates/ 2>/dev/null; then
              echo ""
              
              for service in $(get_target_services); do
                domain=$(get_domain "$service")
                echo "Checking certificate for ${domain}..."
                
                CERT_PATH=$(docker exec caddy_server find /data/caddy/certificates -name "${domain}*" -type d 2>/dev/null | head -1)
                if [[ -n "$CERT_PATH" ]]; then
                  echo "‚úÖ Certificate found for ${domain}"
                  docker exec caddy_server ls -la "$CERT_PATH" 2>/dev/null || true
                else
                  add_warning "No certificate found for ${domain}"
                  echo "‚ö†Ô∏è  No certificate found for ${domain}"
                fi
              done
            else
              add_warning "Could not access Caddy certificate storage"
              echo "‚ö†Ô∏è  Could not access certificate storage"
            fi
            echo ""
            
            echo "=========================================="
            echo "üíæ 10. Disk and Resource Usage"
            echo "=========================================="
            echo ""
            
            echo "Docker disk usage:"
            docker system df
            echo ""
            
            echo "Deployment directory sizes:"
            for service in $(get_target_services); do
              deploy_dir=$(get_deploy_dir "$service")
              if [[ -d "$deploy_dir" ]]; then
                SIZE=$(du -sh "$deploy_dir" 2>/dev/null | cut -f1)
                echo "  ${deploy_dir}: ${SIZE}"
              else
                echo "  ${deploy_dir}: directory not found"
              fi
            done
            echo ""
            
            # ==========================================
            # Summary
            # ==========================================
            
            echo "=========================================="
            echo "üìä Diagnostic Summary"
            echo "=========================================="
            echo ""
            echo "Critical Issues: ${#ISSUES[@]}"
            echo "Warnings: ${#WARNINGS[@]}"
            echo ""
            
            if [[ ${#ISSUES[@]} -gt 0 ]]; then
              echo "‚ùå Critical Issues:"
              for issue in "${ISSUES[@]}"; do
                echo "  - $issue"
              done
              echo ""
            fi
            
            if [[ ${#WARNINGS[@]} -gt 0 ]]; then
              echo "‚ö†Ô∏è  Warnings:"
              for warning in "${WARNINGS[@]}"; do
                echo "  - $warning"
              done
              echo ""
            fi
            
            if [[ ${#ISSUES[@]} -eq 0 && ${#WARNINGS[@]} -eq 0 ]]; then
              echo "‚úÖ All checks passed! No issues detected."
            fi
            echo ""
            
            # ==========================================
            # Step 2: Auto-Fix (if enabled)
            # ==========================================
            
            if [[ "${AUTO_FIX}" == "true" && (${#ISSUES[@]} -gt 0 || ${#WARNINGS[@]} -gt 0) ]]; then
              echo "=========================================="
              echo "üîß Auto-Fix Mode Enabled"
              echo "=========================================="
              echo ""
              
              FIXES_APPLIED=0
              
              # Fix 1: Create caddy-network if it doesn't exist
              echo "Fix 1: Checking caddy-network..."
              if ! docker network inspect caddy-network >/dev/null 2>&1; then
                echo "Creating caddy-network..."
                if docker network create caddy-network; then
                  echo "‚úÖ Created caddy-network"
                  ((FIXES_APPLIED++))
                else
                  echo "‚ùå Failed to create caddy-network"
                fi
              else
                echo "‚úÖ caddy-network already exists"
              fi
              echo ""
              
              # Fix 2: Connect disconnected containers to the network
              echo "Fix 2: Connecting containers to caddy-network..."
              CONNECTED_CONTAINERS=$(docker network inspect caddy-network --format '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null || echo "")
              
              for service in $(get_target_services); do
                if docker ps --format '{{.Names}}' | grep -q "^${service}$"; then
                  if ! echo "$CONNECTED_CONTAINERS" | grep -qw "$service"; then
                    echo "Connecting ${service} to caddy-network..."
                    if docker network connect caddy-network "$service" 2>/dev/null; then
                      echo "‚úÖ Connected ${service} to caddy-network"
                      ((FIXES_APPLIED++))
                    else
                      echo "‚ùå Failed to connect ${service} to caddy-network"
                    fi
                  else
                    echo "‚úÖ ${service} already connected"
                  fi
                fi
              done
              echo ""
              
              # Fix 3: Start stopped containers
              echo "Fix 3: Starting stopped containers..."
              for service in $(get_target_services); do
                if docker ps -a --format '{{.Names}}' | grep -q "^${service}$"; then
                  STATUS=$(docker inspect --format '{{.State.Status}}' "$service" 2>/dev/null || echo "unknown")
                  if [[ "$STATUS" != "running" ]]; then
                    deploy_dir=$(get_deploy_dir "$service")
                    echo "Starting ${service} via docker compose in ${deploy_dir}..."
                    if has_compose_file "$deploy_dir"; then
                      if (cd "$deploy_dir" && docker compose up -d); then
                        echo "‚úÖ Started services in ${deploy_dir}"
                        ((FIXES_APPLIED++))
                      else
                        echo "‚ùå Failed to start services in ${deploy_dir}"
                      fi
                    else
                      echo "‚ö†Ô∏è  No docker compose file found in ${deploy_dir}, trying docker start..."
                      if docker start "$service"; then
                        echo "‚úÖ Started ${service}"
                        ((FIXES_APPLIED++))
                      else
                        echo "‚ùå Failed to start ${service}"
                      fi
                    fi
                  else
                    echo "‚úÖ ${service} is already running"
                  fi
                else
                  deploy_dir=$(get_deploy_dir "$service")
                  if has_compose_file "$deploy_dir"; then
                    echo "Container ${service} doesn't exist, trying to create via docker compose in ${deploy_dir}..."
                    if (cd "$deploy_dir" && docker compose up -d); then
                      echo "‚úÖ Created and started services in ${deploy_dir}"
                      ((FIXES_APPLIED++))
                    else
                      echo "‚ùå Failed to create services in ${deploy_dir}"
                    fi
                  else
                    echo "‚ö†Ô∏è  Deploy directory ${deploy_dir} not found or no compose file, cannot start ${service}"
                  fi
                fi
              done
              echo ""
              
              # Fix 4: Sync Caddyfile if domains are missing
              echo "Fix 4: Checking Caddyfile sync..."
              if [[ ${#CADDYFILE_MISSING_DOMAINS[@]} -gt 0 ]]; then
                echo "Caddyfile is missing ${#CADDYFILE_MISSING_DOMAINS[@]} domain(s). Generating complete Caddyfile..."
                
                CADDY_DEPLOY_PATH="/srv/link-in-bio/Caddyfile"
                if [[ ! -f "$CADDY_DEPLOY_PATH" ]]; then
                  CADDY_DEPLOY_PATH="/home/deploy/link-in-bio/Caddyfile"
                fi
                
                # Generate complete Caddyfile with all required domains
                cat > "${CADDY_DEPLOY_PATH}" << 'CADDYFILE_EOF'
            # Main domain - public-facing Link-in-Bio site
            festas-builds.com {
                tls eric@festas-builds.com
                reverse_proxy web:8000
            }
            
            # Admin subdomain - administrative interface
            admin.festas-builds.com {
                tls eric@festas-builds.com
                reverse_proxy web:8000
            }
            
            # RigPilot subdomain - PC Builder application
            rigpilot.festas-builds.com {
                tls eric@festas-builds.com
                encode gzip zstd
                @static path /_next/static/*
                header @static Cache-Control "public, max-age=31536000, immutable"
                reverse_proxy rigpilot:3000
            }
            
            # ImmoCalc subdomain - Immobilien Investment Calculator
            immocalc.festas-builds.com {
                tls eric@festas-builds.com
                encode gzip zstd
                @static path /_next/static/*
                header @static Cache-Control "public, max-age=31536000, immutable"
                reverse_proxy immocalc:3000
            }
            
            # Minecraft Server Website
            mc.festas-builds.com {
                tls eric@festas-builds.com
                encode gzip zstd
                @static path *.css *.js *.png *.jpg *.jpeg *.gif *.ico *.svg *.woff *.woff2
                header @static Cache-Control "public, max-age=31536000, immutable"
                reverse_proxy minecraft-web:80
            }
            
            # Cosmic Survivor Game
            cs.festas-builds.com {
                tls eric@festas-builds.com
                encode gzip zstd
                @static path *.css *.js *.png *.jpg *.jpeg *.gif *.ico *.svg *.woff *.woff2 *.mp3 *.ogg *.wav
                header @static Cache-Control "public, max-age=31536000, immutable"
                reverse_proxy cosmic-survivor:80
            }
            CADDYFILE_EOF
                
                # Strip all leading whitespace from heredoc content
                sed -i 's/^[[:space:]]*//' "${CADDY_DEPLOY_PATH}" || true
                
                echo "‚úÖ Caddyfile updated with all required domains"
                echo ""
                echo "New Caddyfile contents:"
                cat "${CADDY_DEPLOY_PATH}"
                echo ""
                
                # Copy to Caddy container and reload
                echo "Copying updated Caddyfile to Caddy container..."
                if docker cp "${CADDY_DEPLOY_PATH}" caddy_server:/etc/caddy/Caddyfile; then
                  echo "‚úÖ Caddyfile copied to container"
                  ((FIXES_APPLIED++))
                  
                  # Validate and reload
                  echo "Validating and reloading Caddy configuration..."
                  if docker exec caddy_server caddy validate --config /etc/caddy/Caddyfile 2>&1; then
                    if docker exec caddy_server caddy reload --config /etc/caddy/Caddyfile 2>&1; then
                      echo "‚úÖ Caddy configuration reloaded successfully"
                      ((FIXES_APPLIED++))
                    else
                      echo "‚ö†Ô∏è  Caddy reload failed after Caddyfile update"
                    fi
                  else
                    echo "‚ùå Updated Caddyfile validation failed - reverting may be needed"
                  fi
                else
                  echo "‚ùå Failed to copy Caddyfile to container"
                fi
              else
                echo "‚úÖ Caddyfile has all required domains"
              fi
              echo ""
              
              # Fix 5: Reload Caddy configuration
              echo "Fix 5: Reloading Caddy configuration..."
              if docker exec caddy_server caddy reload --config /etc/caddy/Caddyfile 2>&1; then
                echo "‚úÖ Caddy configuration reloaded"
                ((FIXES_APPLIED++))
              else
                echo "‚ö†Ô∏è  Caddy reload failed, attempting restart..."
                if docker restart caddy_server; then
                  echo "‚úÖ Caddy container restarted"
                  ((FIXES_APPLIED++))
                else
                  echo "‚ùå Failed to restart Caddy"
                fi
              fi
              echo ""
              
              # Fix 6: Restart unhealthy containers
              echo "Fix 6: Checking for unhealthy containers..."
              for service in $(get_target_services); do
                if docker ps --format '{{.Names}}' | grep -q "^${service}$"; then
                  HEALTH=$(docker inspect --format '{{if .State.Health}}{{.State.Health.Status}}{{else}}no healthcheck{{end}}' "$service" 2>/dev/null || echo "unknown")
                  if [[ "$HEALTH" == "unhealthy" ]]; then
                    echo "Restarting unhealthy container ${service}..."
                    if docker restart "$service"; then
                      echo "‚úÖ Restarted ${service}"
                      ((FIXES_APPLIED++))
                    else
                      echo "‚ùå Failed to restart ${service}"
                    fi
                  fi
                fi
              done
              echo ""
              
              # Post-fix verification
              echo "=========================================="
              echo "üîç Post-Fix Verification"
              echo "=========================================="
              echo ""
              
              echo "Waiting 10 seconds for services to stabilize..."
              sleep 10
              
              echo "Verifying connectivity..."
              VERIFICATION_PASSED=true
              
              if is_caddy_running; then
                for service in $(get_target_services); do
                  port=$(get_port "$service")
                  if docker exec caddy_server wget -q --spider --timeout=5 "http://${service}:${port}/" 2>/dev/null || \
                     docker exec caddy_server curl -sf --connect-timeout 5 "http://${service}:${port}/" >/dev/null 2>&1; then
                    echo "‚úÖ ${service}:${port} is now reachable"
                  else
                    echo "‚ùå ${service}:${port} is still NOT reachable"
                    VERIFICATION_PASSED=false
                  fi
                done
              else
                echo "‚ùå Caddy container is not running - cannot verify connectivity"
                VERIFICATION_PASSED=false
              fi
              echo ""
              
              echo "=========================================="
              echo "üìä Auto-Fix Summary"
              echo "=========================================="
              echo ""
              echo "Fixes applied: ${FIXES_APPLIED}"
              if [[ "$VERIFICATION_PASSED" == "true" ]]; then
                echo "‚úÖ All services are now reachable"
              else
                echo "‚ö†Ô∏è  Some services are still not reachable - manual intervention may be required"
              fi
              echo ""
            elif [[ "${AUTO_FIX}" == "true" ]]; then
              echo "=========================================="
              echo "‚ÑπÔ∏è  Auto-Fix Skipped"
              echo "=========================================="
              echo "No issues or warnings detected - nothing to fix."
              echo ""
            fi
            
            echo "=========================================="
            echo "üèÅ Diagnostics Complete"
            echo "=========================================="

      - name: Parse Discovery Results
        id: parse-discovery
        if: always()
        run: |
          # Extract the discovery JSON from SSH output
          SSH_OUTPUT="${{ steps.diagnostics.outputs.stdout }}"
          
          # Try to extract JSON between markers
          if echo "$SSH_OUTPUT" | grep -q "DISCOVERY_JSON_START"; then
            DISCOVERY_JSON=$(echo "$SSH_OUTPUT" | sed -n '/DISCOVERY_JSON_START/,/DISCOVERY_JSON_END/p' | grep -v 'DISCOVERY_JSON_START\|DISCOVERY_JSON_END' || echo '{}')
          else
            DISCOVERY_JSON='{}'
          fi
          
          # Save discovery JSON to file
          echo "$DISCOVERY_JSON" > discovery-report.json
          
          # Parse counts for outputs
          UNKNOWN_COUNT=$(echo "$DISCOVERY_JSON" | jq -r '.summary.unknown_containers // 0' 2>/dev/null || echo "0")
          HEALTHY_UNKNOWN_COUNT=$(echo "$DISCOVERY_JSON" | jq -r '.summary.healthy_unknown // 0' 2>/dev/null || echo "0")
          MISSING_COUNT=$(echo "$DISCOVERY_JSON" | jq -r '.summary.missing_services // 0' 2>/dev/null || echo "0")
          ANOMALY_COUNT=$(echo "$DISCOVERY_JSON" | jq -r '.summary.anomalies // 0' 2>/dev/null || echo "0")
          
          echo "unknown_count=$UNKNOWN_COUNT" >> $GITHUB_OUTPUT
          echo "healthy_unknown_count=$HEALTHY_UNKNOWN_COUNT" >> $GITHUB_OUTPUT
          echo "missing_count=$MISSING_COUNT" >> $GITHUB_OUTPUT
          echo "anomaly_count=$ANOMALY_COUNT" >> $GITHUB_OUTPUT
          
          # Generate markdown report
          cat > discovery-report.md << 'EOF'
          # üîç Server Discovery Report
          
          Generated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
          
          ## Summary
          
          | Category | Count |
          |----------|-------|
          | Unknown Containers | $UNKNOWN_COUNT |
          | Healthy Unknown | $HEALTHY_UNKNOWN_COUNT |
          | Missing Services | $MISSING_COUNT |
          | Anomalies | $ANOMALY_COUNT |
          
          EOF
          
          # Add unknown containers section if any
          if [[ "$UNKNOWN_COUNT" -gt 0 ]]; then
            echo "## Unknown Containers" >> discovery-report.md
            echo "" >> discovery-report.md
            echo "$DISCOVERY_JSON" | jq -r '.unknown_containers[] | "- **\(.name)** (\(.status))\n  - Image: \(.image)\n  - Ports: \(.ports // "none")"' 2>/dev/null >> discovery-report.md || true
            echo "" >> discovery-report.md
          fi
          
          # Add missing services section if any
          if [[ "$MISSING_COUNT" -gt 0 ]]; then
            echo "## Missing Services" >> discovery-report.md
            echo "" >> discovery-report.md
            echo "$DISCOVERY_JSON" | jq -r '.missing_services[] | "- \(.)"' 2>/dev/null >> discovery-report.md || true
            echo "" >> discovery-report.md
          fi
          
          # Add anomalies section if any
          if [[ "$ANOMALY_COUNT" -gt 0 ]]; then
            echo "## Anomalies" >> discovery-report.md
            echo "" >> discovery-report.md
            echo "$DISCOVERY_JSON" | jq -r '.anomalies[] | "- \(.)"' 2>/dev/null >> discovery-report.md || true
            echo "" >> discovery-report.md
          fi
          
          echo "Discovery report generated"

      - name: Auto-Learn Discovered Services
        id: auto-learn
        if: inputs.auto_learn == true && steps.parse-discovery.outputs.healthy_unknown_count != '0'
        run: |
          echo "Auto-learning enabled and healthy unknown containers found"
          
          # Read current config
          CONFIG_FILE=".github/config/known-services.json"
          if [[ -f "$CONFIG_FILE" ]]; then
            CONFIG=$(cat "$CONFIG_FILE")
          else
            CONFIG='{"services": {}, "required_domains": [], "last_discovery": null}'
          fi
          
          # Read discovery results
          DISCOVERY=$(cat discovery-report.json)
          TIMESTAMP=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
          
          # Add healthy unknown containers to config
          UPDATED_CONFIG="$CONFIG"
          SERVICES_ADDED=0
          
          # Extract healthy unknown containers and add them
          echo "$DISCOVERY" | jq -c '.healthy_unknown[]' 2>/dev/null | while read -r container; do
            NAME=$(echo "$container" | jq -r '.name')
            PORTS=$(echo "$container" | jq -r '.ports')
            IMAGE=$(echo "$container" | jq -r '.image')
            
            # Skip if already in config
            if echo "$UPDATED_CONFIG" | jq -e ".services[\"$NAME\"]" >/dev/null 2>&1; then
              echo "Service $NAME already in config, skipping"
              continue
            fi
            
            # Extract port from ports string (e.g., "0.0.0.0:3000->3000/tcp" -> 3000)
            PORT=$(echo "$PORTS" | grep -oE '->([0-9]+)/' | head -1 | grep -oE '[0-9]+' || echo "80")
            
            echo "Adding $NAME to config (port: $PORT)"
            
            # Add to config
            UPDATED_CONFIG=$(echo "$UPDATED_CONFIG" | jq --arg name "$NAME" --arg port "$PORT" --arg ts "$TIMESTAMP" \
              '.services[$name] = {
                "port": ($port | tonumber),
                "domain": null,
                "deploy_dir": null,
                "added": $ts,
                "auto_discovered": true
              }')
            
            SERVICES_ADDED=$((SERVICES_ADDED + 1))
          done
          
          # Update last_discovery timestamp
          UPDATED_CONFIG=$(echo "$UPDATED_CONFIG" | jq --arg ts "$TIMESTAMP" '.last_discovery = $ts')
          
          # Write updated config
          echo "$UPDATED_CONFIG" | jq '.' > "$CONFIG_FILE"
          
          echo "services_added=$SERVICES_ADDED" >> $GITHUB_OUTPUT
          
          if [[ "$SERVICES_ADDED" -gt 0 ]]; then
            echo "Added $SERVICES_ADDED new services to config"
          else
            echo "No new services to add"
          fi

      - name: Commit Updated Config
        if: inputs.auto_learn == true && steps.auto-learn.outputs.services_added != '0'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git add .github/config/known-services.json
          git commit -m "chore: auto-discovered ${{ steps.auto-learn.outputs.services_added }} new service(s)

          Services were automatically discovered during diagnostics run.
          Discovery mode: ${{ inputs.discovery_mode }}
          Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          git push

      - name: Create Issue for Unknown Services
        if: inputs.notify_unknown == true && steps.parse-discovery.outputs.unknown_count != '0'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read discovery report
            let discoveryData = {};
            try {
              discoveryData = JSON.parse(fs.readFileSync('discovery-report.json', 'utf8'));
            } catch (e) {
              console.log('Could not parse discovery report:', e);
              return;
            }
            
            const unknownCount = discoveryData.summary?.unknown_containers || 0;
            const healthyUnknownCount = discoveryData.summary?.healthy_unknown || 0;
            
            if (unknownCount === 0) {
              console.log('No unknown containers to report');
              return;
            }
            
            // Build issue body
            let body = `## üîç Unknown Services Discovered\n\n`;
            body += `During the diagnostics run on ${new Date().toISOString()}, the following unknown containers were discovered:\n\n`;
            
            if (discoveryData.unknown_containers) {
              body += `### Unknown Containers (${unknownCount})\n\n`;
              for (const container of discoveryData.unknown_containers) {
                body += `- **${container.name}**\n`;
                body += `  - Status: ${container.status}\n`;
                body += `  - Image: ${container.image}\n`;
                body += `  - Ports: ${container.ports || 'none'}\n`;
                body += `  - Created: ${container.created}\n\n`;
              }
            }
            
            if (discoveryData.anomalies && discoveryData.anomalies.length > 0) {
              body += `### Anomalies (${discoveryData.anomalies.length})\n\n`;
              for (const anomaly of discoveryData.anomalies) {
                body += `- ${anomaly}\n`;
              }
              body += '\n';
            }
            
            body += `---\n`;
            body += `**Discovery Mode:** ${{ inputs.discovery_mode }}\n`;
            body += `**Auto-Learn:** ${{ inputs.auto_learn }}\n`;
            body += `**Workflow Run:** [View Run](${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID})\n`;
            
            // Check for existing open issues with same label
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'diagnostics',
              state: 'open'
            });
            
            // Create or update issue
            if (existingIssues.data.length > 0) {
              // Update existing issue
              const issue = existingIssues.data[0];
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issue.number,
                body: body
              });
              console.log(`Updated existing issue #${issue.number}`);
            } else {
              // Create new issue
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: `üîç Unknown Services Discovered (${unknownCount} containers)`,
                body: body,
                labels: ['diagnostics']
              });
              console.log('Created new diagnostics issue');
            }

      - name: Upload Discovery Artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: discovery-reports
          path: |
            discovery-report.json
            discovery-report.md
          retention-days: 30
